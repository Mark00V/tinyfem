#######################################################################################
KNOWN BUGS:
-> check_geometry() in Class Geometry: Funktioniert nicht für Linien mit Steigung inf



#######################################################################################
TODOs:
--> GUI: Add button show geometry (nachdem Mesh generiert wurde)
--> GUI: Schreibe in Infofenster alle Infos!
--> Output solution consecutive filename
--> Docstrings and typehints
--> Weitere Überprüfung Geometrie auf Kompatibilität (Entweder in Klasse Geometry oder CreateBCParams)
--> Hilfe-Button in Fenstern GUI, GEOMETRY und SHOWSOLUTION mit kleiner Erläuterung
--> GEOMETRY: Bei Laden von Geometrie verschwindet Fenster GEOMETRY in Hintergrund
--> Unit sollte aus Geometry in Solution übernommen werden und für Achsen angezeigt werden
--> Bei ungültiger Geometrie wird CompatibilityError geraist --> sollte in Fehler-Fenster angezeigt werden
--> Trace für Anzeige Class Geometry Nodes und Polygons ähnlich Boundary Definition
--> Polygonerstellung und Punkteerstellung grafisch in Class Geometry ähnlich outdated Version von "Acoustics"
#######################################################################################
CODEFLOW:

1) Geometrieerstellung
GUI -> define_geometry() -> Class Geometry
    Übergabewerte:  Keine
    Rückgabewerte:  self.geometry_input
                    self.geometry_input ist dict der form:
                    {'polygons':    {   '0': {'coordinates': [[-2.0, -2.0], [2.0, -2.0], [2.0, 2.0], [1.0, 2.0], [-2.0, 1.0]], 'area_neg_pos': 'Positive'},
                                        '1': {'coordinates': [[2.0, 2.0], [2.0, 3.0], [1.0, 3.0], [1.0, 2.0]], 'area_neg_pos': 'Positive'},
                                        '2': {'coordinates': [[1.0, 2.0], [-2.0, 2.0], [-2.0, 1.0]], 'area_neg_pos': 'Positive'},
                                        '3': {'coordinates': [[0.0, 0.0], [1.0, 0.0], [1.0, 1.0]], 'area_neg_pos': 'Negative'}},
                    'points': {'0': [-1.0, -1.0], '1': [-1.5, -1.5]}, 'units': 'm', 'other': None}

2) Vorbereiten Randbedingungen und Regionen
GUI -> receive_geometry() -> Class CreateBCParams()
    Übergabewerte:  self.geometry_input
    Rückgabewerte:  self.regions:       {'0': {'coordinates': [(0.0, 0.0), (1.0, 0.0), (1.0, 1.0), (0.0, 1.0)], 'area_neg_pos': 'Positive'},
                                         '1': {'coordinates': [(0.0, 1.0), (1.0, 1.0), (1.0, 2.0)], 'area_neg_pos': 'Positive'}}
                    self.boundaries :   {'0': ((0.0, 0.0), (1.0, 0.0)),
                                         '1': ((1.0, 0.0), (1.0, 1.0)),
                                         '2': ((1.0, 1.0), (0.0, 1.0)),
                                         '3': ((0.0, 1.0), (0.0, 0.0)), '4': ((1.0, 1.0), (1.0, 2.0)), '5': ((1.0, 2.0), (0.0, 1.0))}
                    self.nodes:         {'0': (0.5, 0.5),
                                         '1': (0.0, 0.0),
                                         '2': (1.0, 0.0), '3': (1.0, 1.0), '4': (0.0, 1.0), '5': (1.0, 2.0)}

3) Initialisieren für Definition von Randbedingungen, Regionen und Calculation Parametern
GUI -> init_parameters()
    Übergabewerte: self.regions
                   self.boundaries
                   self.nodes
    Rückgabewerte:  self.region_parameters      : {'0': {'coordinates': [(0.0, 0.0), (1.0, 0.0), (1.0, 1.0), (0.0, 1.0)], 'area_neg_pos': 'Positive', 'material': {'k': 0, 'c': 0, 'rho': 0}},
                                                   '1': {'coordinates': [(0.0, 1.0), (1.0, 1.0), (1.0, 2.0)], 'area_neg_pos': 'Positive', 'material': {'k': 0, 'c': 0, 'rho': 0}}}
                    self.boundary_parameters    : {'0': {'coordinates': [(0.0, 0.0), (1.0, 0.0)], 'bc': {'type': None, 'value': None}},
                                                   '1': {'coordinates': [(1.0, 0.0), (1.0, 1.0)], 'bc': {'type': None, 'value': None}}, '2': {'coordinates': [(1.0, 1.0), (0.0, 1.0)], 'bc': {'type': None, 'value': None}}, '3': {'coordinates': [(0.0, 1.0), (0.0, 0.0)], 'bc': {'type': None, 'value': None}}, '4': {'coordinates': [(1.0, 1.0), (1.0, 2.0)], 'bc': {'type': None, 'value': None}}, '5': {'coordinates': [(1.0, 2.0), (0.0, 1.0)], 'bc': {'type': None, 'value': None}}}
                    self.node_parameters        : {'0': {'coordinates': (0.5, 0.5), 'bc': {'type': None, 'value': None}},
                                                   '1': {'coordinates': (0.0, 0.0), 'bc': {'type': None, 'value': None}}, '2': {'coordinates': (1.0, 0.0), 'bc': {'type': None, 'value': None}}, '3': {'coordinates': (1.0, 1.0), 'bc': {'type': None, 'value': None}}, '4': {'coordinates': (0.0, 1.0), 'bc': {'type': None, 'value': None}}, '5': {'coordinates': (1.0, 2.0), 'bc': {'type': None, 'value': None}}}
                    self.calculation_parameters : {'mesh_density': None, 'freq': None, 'equation': 'HE', 'units': 'm'}

4) Definition von Randbedingungen, Regionen und Calculation Parametern
GUI -> assign_BCs() | assign_materials() | assign_calc_params()
    assign_BCs:         Übergabewerte: Keine, Befüllen des in Schritt 3 erstellten Dicts
    assign_materials:   Übergabewerte: Keine, Befüllen des in Schritt 3 erstellten Dicts
    assign_calc_params: Übergabewerte: Keine, Befüllen des in Schritt 3 erstellten Dicts

5) Erstellung Mesh
GUI -> create_mesh() --> Class CreateMesh
    Übergabewerte: self.region_parameters
                   self.boundary_parameters
                   self.node_parameters
                   self.calculation_parameters
    Rückgabewerte:  self.nodes_mesh_gen             : np.array([[0.25, 0.25], [0.5,  0.25], [0.75, 0.25], ..., [0.25 0.5 ]])
                    self.single_nodes_dict          : {'0': 4, '1': 9, '2': 13, '3': 17, '4': 21, '5': 31} -> Key: Nummer des Nodes, Value: Position in self.nodes_mesh_gen
                    self.boundary_nodes_dict        : {'0': [[9, array([0., 0.])], [10, array([0.25, 0.  ])], [11, array([0.5, 0. ])], [12, array([0.75, 0.  ])], [13, array([1., 0.])]],
                                                       '1': [[13, array([1., 0.])], [14, array([1.  , 0.25])], [15, array([1. , 0.5])], [16, array([1.  , 0.75])], [17, array([1., 1.])]],
                                                       '2': [[17, array([1., 1.])], [18, array([0.75, 1.  ])], [19, array([0.5, 1. ])], [20, array([0.25, 1.  ])], [21, array([0., 1.])]]}
                                                     key: Nummer Boundary, Value: Liste mit [Position Knoten in self.nodes_mesh_gen, Knotenkoordinaten als np.array]
                    self.triangulation              : np.array([[14., 12., 13.],
                                                               [12., 14.,  2.],
                                                               [18., 16., 17.],
                                                               ...
                                                               [ 5. 16.  8.]])
                                                     Triangulation, Werte in Zeilen sind Positionen Knoten in self.nodes_mesh_gen
                    self.triangulation_region_dict  : {'0': range(0, 32), '1': range(32, 49)}
                                                      key: Nummer Region, Value: Liste der Positionen zugeordneter Knoten in self.nodes_mesh_gen

6) Erstellung Lösung
GUI -> solve_system() -> Class CalcFEM
    Übergabewerte:  self.nodes_mesh_gen
                    self.single_nodes_dict
                    self.boundary_nodes_dict
                    self.triangulation
                    self.triangulation_region_dict
                    self.region_parameters
                    self.boundary_parameters
                    self.node_parameters
                    self.calculation_parameters
    Rückgabewerte:  self.solution   : np.array([1.51028333, 1.32707619, 1.25521119, ..., 1.71405714])
                                     Lösungswerte an den Positionen in self.nodes_mesh_gen

7) Ausgabe Lösung
GUI (automatisch nach solve_system()) -> Class ShowSolution
    Übergabewerte:  self.solution
                    self.nodes_mesh_gen
                    self.triangulation

    Rückgabewerte: Keine
#######################################################################################



Order of Operations for implementing both Dirichlet and Robin boundary conditions in pseudo code:

systemmatrix = assembleMatrix()  # Calculation of the system matrix without boundary conditions using only the element matrices for the regions
forcevector = assembleForceVector()  # Calculation of the force vector (right hand side vector) without boundary conditions

boundarymatrix = assembleBoundaryMatrix()  # Calculates the matrix of boundary elements with Neumann or Robin boundary conditions
systemmatrix += boundarymatrix  # Introduces the boundary elements with Neumann or Robin boundary conditions in the system matrix

# Calculate additional force vector contributions due to Robin boundary conditions
forcevector = applyRobinBoundaryConditions(forcevector)

# Apply Dirichlet boundary conditions after all other modifications to the system matrix and force vector
systemmatrix, forcevector = applyDirichletBoundaryConditions(systemmatrix, forcevector)

# solve system:
solution = np.linalg.solve(systemmatrix, forcevector)

# Function to apply Robin boundary conditions to the force vector
def applyRobinBoundaryConditions(forcevector):
    # pos are the positions of the nodes with robin boundary condition
    # robin_gamma and robin_g are the robin boundary condition values
    for pos, (robin_gamma, robin_g) in robin_values:
        forcevector[pos] += integrate(robin_gamma * robin_g, boundary_element)
    return forcevector

# Function to apply Dirichlet boundary conditions to the system matrix and force vector
def applyDirichletBoundaryConditions(systemmatrix, forcevector):
    # Zero out the rows and columns in the system matrix corresponding to Dirichlet boundaries
    # and set the diagonal entries to 1
    for pos in positions_dirichlet:
        systemmatrix[:, pos] = 0
        systemmatrix[pos, :] = 0
        systemmatrix[pos, pos] = 1

    # Modify the force vector for Dirichlet boundary conditions
    for pos, value in dirichlet_list:
        forcevector = forcevector - systemmatrix[:, pos] * value
        forcevector[pos] = value

    return systemmatrix, forcevector





